import http from 'k6/http';
import { check, sleep, group } from 'k6';
import { SharedArray } from 'k6/data';
import { Rate, Trend } from 'k6/metrics';
import { randomIntBetween } from 'https://jslib.k6.io/k6-utils/1.2.0/index.js';

// Enhanced metrics for better reporting
const rateLimitErrors = new Rate('rate_limit_errors');
const rateLimitErrorsByEndpoint = {};
const responseTimeByEndpoint = {};
const maxRetryCount = new Trend('max_retry_count');
const backoffDuration = new Trend('backoff_duration_ms');
const operationSuccessRate = new Rate('operation_success_rate');
const unknownEndpointTime = new Trend('response_time_unknown');

// Pre-declare all endpoint-specific metrics in the init context
const ENDPOINTS = [
  'login', 'get_products', 'check_card', 'create_card', 'create_order_record',
  'get_latest_order', 'create_order_item', 'get_card_balance', 'update_card_balance'
];

// Initialize all endpoint metrics in init context
ENDPOINTS.forEach(endpoint => {
  rateLimitErrorsByEndpoint[endpoint] = new Rate(`rate_limit_${endpoint}`);
  responseTimeByEndpoint[endpoint] = new Trend(`response_time_${endpoint}`);
});

// Define base URL and API key
const BASE_URL = 'https://dqghjrpeoyqvkvoivfnz.supabase.co';
const API_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRxZ2hqcnBlb3lxdmt2b2l2Zm56Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQwMjE5MDgsImV4cCI6MjA1OTU5NzkwOH0.zzvFJVZ_b4zFe54eTY2iuE0ce-AkhdjjLWewSDoFu-Y';

// Bar credentials for testing - using alex@lesaperosduchateau.be as it's a known valid admin user
const barCredentials = [
  { email: 'alex@lesaperosduchateau.be', password: 'g7YyT3KhWR84' },
];

// Generate a unique ID for this test run to avoid collisions
const testRunId = new Date().getTime();

// Simulated card IDs - would be generated by NFC in real use
const simulatedCardIds = new SharedArray('simulatedCardIds', function() {
  const cards = [];
  for (let i = 1; i <= 100; i++) {
    cards.push(`simulated-card-${testRunId}-${i}`);
  }
  return cards;
});

// Define product categories for better randomization
const productCategories = ['drinks', 'food', 'deposits', 'returns'];

// k6 options - Progressive load testing with multiple stages
export const options = {
  scenarios: {
    low_load: {
      executor: 'ramping-vus',
      startVUs: 1,
      stages: [
        { duration: '30s', target: 5 },   // Gradually ramp up to 5 users
        { duration: '1m', target: 5 },    // Stay at 5 users for 1 minute
      ],
      gracefulRampDown: '10s',
    },
    medium_load: {
      executor: 'ramping-vus',
      startVUs: 5,
      stages: [
        { duration: '30s', target: 10 },  // Ramp up to 10 users
        { duration: '1m', target: 10 },   // Stay at 10 users for 1 minute
      ],
      gracefulRampDown: '10s',
      startTime: '2m',  // Start after the low load finishes
    },
    high_load: {
      executor: 'ramping-vus', 
      startVUs: 10,
      stages: [
        { duration: '30s', target: 20 },  // Push to 20 users
        { duration: '1m', target: 20 },   // Stay at high load
      ],
      gracefulRampDown: '10s',
      startTime: '4m',  // Start after medium load finishes
    },
    extreme_load: {
      executor: 'ramping-arrival-rate',
      startRate: 10,
      timeUnit: '1s',
      preAllocatedVUs: 30,
      maxVUs: 50,
      stages: [
        { duration: '30s', target: 20 },  // Ramp up to extreme load
        { duration: '30s', target: 30 },  // Push system to limits
        { duration: '30s', target: 10 },  // Ramp down
      ],
      startTime: '6m',  // Start after high load finishes
    }
  },
  thresholds: {
    http_req_failed: ['rate<0.3'], // Allow up to 30% of requests to fail (higher threshold for testing)
    'rate_limit_errors': ['rate<0.20'], // Track rate limit errors separately
    'operation_success_rate': ['rate>0.7'], // At least 70% of operations should succeed
    'http_req_duration': ['p(95)<5000'], // 95% of requests should be under 5s
  },
};

// Function to get rate limit metric for an endpoint - now just returns the pre-created metric
function getOrCreateRateLimitMetric(endpoint) {
  return rateLimitErrorsByEndpoint[endpoint] || rateLimitErrors; // Fallback to global metric
}

// Function to get response time metric for an endpoint - now just returns the pre-created metric
function getOrCreateResponseTimeMetric(endpoint) {
  return responseTimeByEndpoint[endpoint] || unknownEndpointTime; // Use pre-created fallback
}

// Enhanced retry function with better logging and metrics
function rateLimitedRequest(method, url, body = null, params = {}) {
  const maxRetries = 5;
  let retries = 0;
  let result;
  let totalBackoffTime = 0;
  const endpoint = params.name || url.split('/').slice(-1)[0].split('?')[0]; // Extract endpoint name for metrics

  const baseParams = {
    headers: {
      'apikey': API_KEY,
      'Content-Type': 'application/json',
      ...params.headers
    },
    tags: { name: params.name || url }
  };
  
  const fullParams = { ...baseParams, ...params };
  
  // Get or create endpoint-specific metrics
  const endpointRateLimitMetric = getOrCreateRateLimitMetric(endpoint);
  const endpointResponseTime = getOrCreateResponseTimeMetric(endpoint);
  
  // Random jitter to avoid thundering herd problem
  if (params.addInitialJitter) {
    const jitter = Math.random() * 500; // Up to 500ms jitter
    sleep(jitter / 1000);
  }
  
  const startTime = new Date();
  
  while (retries < maxRetries) {
    if (retries > 0) {
      // Exponential backoff with jitter: Base * (2^retry) * (0.5-1.5 random factor)
      const randomFactor = 0.5 + Math.random();
      const backoffTime = Math.pow(2, retries) * 500 * randomFactor;
      totalBackoffTime += backoffTime;
      
      console.log(`[${endpoint}] Retry ${retries}/${maxRetries}, backing off for ${backoffTime.toFixed(0)}ms`);
      sleep(backoffTime / 1000); // convert ms to seconds for k6 sleep
    }
    
    let requestStartTime = new Date();
    
    if (method === 'GET') {
      result = http.get(url, fullParams);
    } else if (method === 'POST') {
      result = http.post(url, body ? JSON.stringify(body) : null, fullParams);
    } else if (method === 'PUT') {
      result = http.put(url, body ? JSON.stringify(body) : null, fullParams);
    } else if (method === 'PATCH') {
      result = http.patch(url, body ? JSON.stringify(body) : null, fullParams);
    } else if (method === 'DELETE') {
      result = http.del(url, body ? JSON.stringify(body) : null, fullParams);
    }
    
    endpointResponseTime.add(new Date() - requestStartTime);
    
    // Check for rate limiting
    if (result.status === 429) {
      console.log(`[${endpoint}] Rate limited, attempt ${retries + 1}/${maxRetries}`);
      rateLimitErrors.add(1);
      endpointRateLimitMetric.add(1);
      retries++;
      continue;
    }
    
    // No rate limiting, return the result
    maxRetryCount.add(retries);
    if (totalBackoffTime > 0) {
      backoffDuration.add(totalBackoffTime);
    }
    return result;
  }
  
  // If we get here, we've exhausted our retries
  console.log(`[${endpoint}] Failed after ${maxRetries} retries`);
  maxRetryCount.add(maxRetries);
  backoffDuration.add(totalBackoffTime);
  return result;
}

// Function to handle the order creation process with enhanced randomization and error tracking
function createOrder(authHeader, cardId, products, totalAmount = null) {
  try {
    // Select a random number of products (1-5)
    const numProducts = randomIntBetween(1, 5);
    
    // First filter products by category to ensure a good mix
    const categorizedProducts = {};
    productCategories.forEach(category => {
      categorizedProducts[category] = products.filter(p => 
        (p.category === category) || 
        (category === 'returns' && p.is_return === true) ||
        (category === 'deposits' && p.is_deposit === true)
      );
    });
    
    // Build order items with better randomization
    const orderItems = [];
    let calculatedTotal = 0;
    
    // Always include at least one regular product (drink or food)
    const regularCategories = ['drinks', 'food'];
    const regularCategory = regularCategories[randomIntBetween(0, regularCategories.length - 1)];
    
    if (categorizedProducts[regularCategory] && categorizedProducts[regularCategory].length > 0) {
      const randomProduct = categorizedProducts[regularCategory][randomIntBetween(0, categorizedProducts[regularCategory].length - 1)];
      const quantity = randomIntBetween(1, 3);
      
      if (randomProduct && randomProduct.price !== null) {
        orderItems.push({
          product_name: randomProduct.name,
          price: randomProduct.price,
          quantity: quantity,
          is_deposit: randomProduct.is_deposit || false,
          is_return: randomProduct.is_return || false
        });
        
        calculatedTotal += randomProduct.price * quantity;
      }
    }
    
    // Maybe add a deposit (20% chance if deposits exist)
    if (Math.random() < 0.2 && categorizedProducts['deposits'] && categorizedProducts['deposits'].length > 0) {
      const depositProduct = categorizedProducts['deposits'][randomIntBetween(0, categorizedProducts['deposits'].length - 1)];
      const depositQuantity = randomIntBetween(1, 2);
      
      if (depositProduct && depositProduct.price !== null) {
        orderItems.push({
          product_name: depositProduct.name,
          price: depositProduct.price,
          quantity: depositQuantity,
          is_deposit: true,
          is_return: false
        });
        
        calculatedTotal += depositProduct.price * depositQuantity;
      }
    }
    
    // Maybe add a return (10% chance if returns exist)
    if (Math.random() < 0.1 && categorizedProducts['returns'] && categorizedProducts['returns'].length > 0) {
      const returnProduct = categorizedProducts['returns'][randomIntBetween(0, categorizedProducts['returns'].length - 1)];
      const returnQuantity = randomIntBetween(1, 2);
      
      if (returnProduct && returnProduct.price !== null) {
        orderItems.push({
          product_name: returnProduct.name,
          price: returnProduct.price,
          quantity: returnQuantity,
          is_deposit: false,
          is_return: true
        });
        
        calculatedTotal -= returnProduct.price * returnQuantity;
      }
    }
    
    // Add additional random products to reach the desired number of items
    while (orderItems.length < numProducts && products.length > 0) {
      const randomProduct = products[randomIntBetween(0, products.length - 1)];
      const quantity = randomIntBetween(1, 3);
      
      // Skip products with null prices to avoid errors
      if (randomProduct.price === null) {
        continue;
      }
      
      // Skip if we already have this product (to avoid duplicates)
      if (orderItems.some(item => item.product_name === randomProduct.name)) {
        continue;
      }
      
      orderItems.push({
        product_name: randomProduct.name,
        price: randomProduct.price,
        quantity: quantity,
        is_deposit: randomProduct.is_deposit || false,
        is_return: randomProduct.is_return || false
      });
      
      // Update the total based on the item type
      if (randomProduct.is_return) {
        calculatedTotal -= randomProduct.price * quantity;
      } else {
        calculatedTotal += randomProduct.price * quantity;
      }
    }
    
    // Ensure we have at least one item
    if (orderItems.length === 0) {
      throw new Error('Failed to create valid order items');
    }
    
    // Use provided total if specified, otherwise use calculated
    const finalTotal = totalAmount !== null ? totalAmount : calculatedTotal;
    
    console.log(`Creating order for card ${cardId} with ${orderItems.length} items, total: ${finalTotal.toFixed(2)}`);
    
    // Step 1: Create the order record first
    const orderData = {
      card_id: cardId,
      total_amount: finalTotal,
      status: 'completed'
    };
    
    const createOrderUrl = `${BASE_URL}/rest/v1/bar_orders`;
    const createOrderResponse = rateLimitedRequest('POST', createOrderUrl, orderData, {
      headers: { ...authHeader, 'Prefer': 'return=representation' },
      name: 'create_order_record'
    });
    
    if (createOrderResponse.status !== 201 && createOrderResponse.status !== 200) {
      console.error(`Failed to create order record: ${createOrderResponse.status} ${createOrderResponse.body}`);
      return { success: false, stage: 'create_order', status: createOrderResponse.status };
    }
    
    // Extract the order ID from the response
    let orderId;
    try {
      // Check the response to see if it has a body
      if (!createOrderResponse.body || createOrderResponse.body === '{}') {
        // Try to get the order ID from the Location header
        const locationHeader = createOrderResponse.headers['Location'] || createOrderResponse.headers['location'];
        if (locationHeader) {
          // Extract the ID from something like '/rest/v1/bar_orders?id=eq.123'
          const match = locationHeader.match(/id=eq\.([^&]+)/);
          if (match && match[1]) {
            orderId = match[1];
            console.log(`Extracted order ID from Location header: ${orderId}`);
          }
        }
        
        // If we still don't have an order ID, query for the most recent order for this card
        if (!orderId) {
          console.log('No order ID in response, querying for the latest order');
          const getOrderUrl = `${BASE_URL}/rest/v1/bar_orders?card_id=eq.${cardId}&order=created_at.desc&limit=1`;
          const getOrderResponse = rateLimitedRequest('GET', getOrderUrl, null, {
            headers: authHeader,
            name: 'get_latest_order'
          });
          
          if (getOrderResponse.status === 200 && getOrderResponse.json().length > 0) {
            orderId = getOrderResponse.json()[0].id;
            console.log(`Found latest order ID: ${orderId}`);
          }
        }
      } else {
        // Try to parse the order ID from the response body
        try {
          const orderResult = JSON.parse(createOrderResponse.body);
          if (Array.isArray(orderResult) && orderResult.length > 0) {
            orderId = orderResult[0].id;
          } else if (orderResult.id) {
            orderId = orderResult.id;
          }
        } catch (parseError) {
          console.error('Error parsing order response JSON:', parseError);
        }
      }
      
      if (!orderId) {
        console.error('Could not determine order ID from response');
        return { success: false, stage: 'extract_order_id', error: 'No order ID found' };
      }
    } catch (error) {
      console.error('Error processing order response:', error);
      return { success: false, stage: 'process_response', error: error.message };
    }
    
    // Wait briefly to ensure the order is committed
    sleep(0.5);
    
    // Step 2: Create the order items
    const orderItemsData = orderItems.map(item => ({
      order_id: orderId,
      product_name: item.product_name,
      price: item.price,
      quantity: item.quantity,
      is_deposit: item.is_deposit || false,
      is_return: item.is_return || false
    }));
    
    // Create items one by one with better error tracking
    let itemsCreated = 0;
    let itemErrors = 0;
    
    for (const item of orderItemsData) {
      const createItemUrl = `${BASE_URL}/rest/v1/bar_order_items`;
      const createItemResponse = rateLimitedRequest('POST', createItemUrl, item, {
        headers: authHeader,
        name: 'create_order_item'
      });
      
      if (createItemResponse.status === 201 || createItemResponse.status === 200) {
        itemsCreated++;
      } else {
        console.error(`Failed to create order item: ${createItemResponse.status} ${createItemResponse.body}`);
        itemErrors++;
      }
      
      // Small pause between item creations with randomization
      sleep(0.1 + (Math.random() * 0.3));
    }
    
    // Step 3: Update the card balance (as the app does)
    // Get current card balance
    const getCardUrl = `${BASE_URL}/rest/v1/table_cards?id=eq.${cardId}&select=amount`;
    const getCardResponse = rateLimitedRequest('GET', getCardUrl, null, {
      headers: authHeader,
      name: 'get_card_balance'
    });
    
    if (getCardResponse.status === 200 && getCardResponse.json().length > 0) {
      const cardData = getCardResponse.json()[0];
      const currentAmount = parseFloat(cardData.amount || '0');
      const newAmount = (currentAmount - finalTotal).toString();
      
      // Update the card balance
      const updateCardUrl = `${BASE_URL}/rest/v1/table_cards?id=eq.${cardId}`;
      const updateCardResponse = rateLimitedRequest('PATCH', updateCardUrl, { amount: newAmount }, {
        headers: { ...authHeader, 'Prefer': 'return=minimal' },
        name: 'update_card_balance'
      });
      
      if (updateCardResponse.status !== 204 && updateCardResponse.status !== 200) {
        console.error(`Failed to update card balance: ${updateCardResponse.status} ${updateCardResponse.body}`);
        return { 
          success: false, 
          orderId: orderId, 
          itemsCreated: itemsCreated,
          itemErrors: itemErrors,
          stage: 'update_balance',
          status: updateCardResponse.status
        };
      }
    } else {
      console.error(`Failed to get card data: ${getCardResponse.status} ${getCardResponse.body}`);
      return { 
        success: false, 
        orderId: orderId, 
        itemsCreated: itemsCreated,
        itemErrors: itemErrors,
        stage: 'get_card',
        status: getCardResponse.status
      };
    }
    
    return { 
      success: true,
      orderId: orderId,
      itemsCreated: itemsCreated,
      itemErrors: itemErrors,
      orderTotal: finalTotal
    };
  } catch (error) {
    console.error('Error in order creation process:', error);
    return { success: false, error: error.message };
  }
}

export default function() {
  let stageSuccess = false;
  
  group('Bar operation test', function() {
    try {
      // Log current stage for better reporting
      console.log(`Running bar operation - VU: ${__VU}, iteration: ${__ITER}`);

      // Randomly select a bar user
      const barCredential = barCredentials[Math.floor(Math.random() * barCredentials.length)];
      
      group('Login', function() {
        console.log(`Logging in as ${barCredential.email}`);
        const loginResponse = rateLimitedRequest('POST', `${BASE_URL}/auth/v1/token?grant_type=password`, {
          email: barCredential.email,
          password: barCredential.password
        }, {
          name: 'login',
          addInitialJitter: true // Add jitter to avoid all VUs hitting login at the same time
        });
        
        // Check if login was successful
        if (!check(loginResponse, { 'login successful': (r) => r.status === 200 && r.json('access_token') !== undefined })) {
          console.error(`Login failed: ${loginResponse.status} ${loginResponse.body}`);
          sleep(randomIntBetween(2, 4));
          return;
        }
        
        // Get access token
        const accessToken = loginResponse.json('access_token');
        // Include the API key in the auth header
        const authHeader = { 
          'Authorization': `Bearer ${accessToken}`,
          'apikey': API_KEY
        };
        
        // Sleep a random amount to spread out requests
        sleep(Math.random() * 2);
        
        group('Get products', function() {
          // Get bar products - Use the correct table name 'bar_products' instead of 'products'
          const productsUrl = `${BASE_URL}/rest/v1/bar_products?select=*`;
          const productsResponse = rateLimitedRequest('GET', productsUrl, null, {
            headers: authHeader,
            name: 'get_products'
          });
          
          if (!check(productsResponse, { 'products retrieved': (r) => r.status === 200 && r.json().length > 0 })) {
            console.error(`No products found: ${productsResponse.status} ${productsResponse.body}`);
            sleep(randomIntBetween(2, 4));
            return;
          }
          
          // Get available products
          const products = productsResponse.json();
          if (products.length === 0) {
            console.error('No products available');
            sleep(randomIntBetween(2, 4));
            return;
          }
          
          group('Card operations', function() {
            // Randomly select card
            const cardId = simulatedCardIds[Math.floor(Math.random() * simulatedCardIds.length)];
            
            // Check if card exists, create if not (this helps with test stability)
            const cardCheckUrl = `${BASE_URL}/rest/v1/table_cards?id=eq.${cardId}&select=id,amount`;
            const cardCheckResponse = rateLimitedRequest('GET', cardCheckUrl, null, {
              headers: authHeader,
              name: 'check_card'
            });
            
            if (cardCheckResponse.json().length === 0) {
              console.log(`Creating test card: ${cardId}`);
              
              // Randomize initial card balance (50-200)
              const initialBalance = (50 + Math.random() * 150).toFixed(2);
              
              const createCardResponse = rateLimitedRequest('POST', `${BASE_URL}/rest/v1/table_cards`, {
                id: cardId,
                amount: initialBalance,
                description: 'Test load card'
              }, {
                headers: authHeader,
                name: 'create_card'
              });
              
              if (!check(createCardResponse, { 'card created': (r) => r.status === 201 })) {
                console.error(`Failed to create card: ${createCardResponse.status} ${createCardResponse.body}`);
                sleep(randomIntBetween(2, 4));
                return;
              }
              
              // Sleep to make sure the card is created before we try to use it
              sleep(randomIntBetween(0.8, 1.5));
            }
            
            // Random delay
            sleep(Math.random() * 1);
            
            group('Process order', function() {
              // Use enhanced createOrder function
              const orderResult = createOrder(authHeader, cardId, products);
              
              check(orderResult, { 
                'order created successfully': (r) => r.success === true,
                'all items created': (r) => r.success && r.itemsCreated > 0 && r.itemErrors === 0,
              });
              
              // Track overall operation success
              operationSuccessRate.add(orderResult.success ? 1 : 0);
              
              // Record more detailed information if the operation failed
              if (!orderResult.success) {
                console.log(`Order creation failed at stage: ${orderResult.stage}, status: ${orderResult.status}, error: ${orderResult.error || 'unknown'}`);
              } else {
                console.log(`Order creation successful - ID: ${orderResult.orderId}, Items: ${orderResult.itemsCreated}, Total: ${orderResult.orderTotal}`);
                stageSuccess = true;
              }
            });
          });
        });
      });
      
      // Sleep to allow some time between complete operations
      sleep(randomIntBetween(3, 6));
      
    } catch (error) {
      console.error(`Unhandled error in bar operation: ${error.message}`);
    }
  });
  
  // Track overall success of the execution
  operationSuccessRate.add(stageSuccess ? 1 : 0);
} 